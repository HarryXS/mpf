<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mpf.devices.playfield module &mdash; Mission Pinball Framework v0.21.0 API Documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.21.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Mission Pinball Framework v0.21.0 API Documentation" href="index.html" />
    <link rel="up" title="mpf.devices package" href="mpf.devices.html" />
    <link rel="next" title="mpf.devices.playfield_transfer module" href="mpf.devices.playfield_transfer.html" />
    <link rel="prev" title="mpf.devices.new_device_template module" href="mpf.devices.new_device_template.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mpf.devices.playfield_transfer.html" title="mpf.devices.playfield_transfer module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mpf.devices.new_device_template.html" title="mpf.devices.new_device_template module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Mission Pinball Framework v0.21.0 API Documentation</a> &raquo;</li>
          <li><a href="mpf.html" >mpf package</a> &raquo;</li>
          <li><a href="mpf.devices.html" accesskey="U">mpf.devices package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-mpf.devices.playfield">
<span id="mpf-devices-playfield-module"></span><h1>mpf.devices.playfield module</h1>
<p>Contains the Playfield device class which represents the actual playfield in
a pinball machine.</p>
<dl class="class">
<dt id="mpf.devices.playfield.Playfield">
<em class="property">class </em><tt class="descclassname">mpf.devices.playfield.</tt><tt class="descname">Playfield</tt><big>(</big><em>machine</em>, <em>name</em>, <em>config</em>, <em>collection=None</em>, <em>validate=True</em><big>)</big></dt>
<dd><p>Bases: <a class="reference internal" href="mpf.devices.ball_device.html#mpf.devices.ball_device.BallDevice" title="mpf.devices.ball_device.BallDevice"><tt class="xref py py-class docutils literal"><span class="pre">mpf.devices.ball_device.BallDevice</span></tt></a></p>
<dl class="method">
<dt id="mpf.devices.playfield.Playfield.add_ball">
<tt class="descname">add_ball</tt><big>(</big><em>balls=1</em>, <em>source_name=None</em>, <em>source_device=None</em>, <em>player_controlled=False</em>, <em>reset=False</em><big>)</big></dt>
<dd><p>Adds live ball(s) to the playfield.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>balls</strong> &#8211; Integer of the number of balls you&#8217;d like to add.</li>
<li><strong>source_name</strong> &#8211; Optional string name of the ball device you&#8217;d like to
add the ball(s) from.</li>
<li><strong>source_device</strong> &#8211; Optional ball device object you&#8217;d like to add the
ball(s) from.</li>
<li><strong>player_controlled</strong> &#8211; Boolean which specifies whether this event is
player controlled. (See not below for details)</li>
<li><strong>reset</strong> &#8211; Boolean which controls whether the source device should
reset its state to idle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if it&#8217;s able to process the add_ball() request, False if it
cannot.</p>
</td>
</tr>
</tbody>
</table>
<p>Both source_name and source_device args are included to give you two
options for specifying the source of the ball(s) to be added. You don&#8217;t
need to supply both. (it&#8217;s an &#8220;either/or&#8221; thing.) Both of these args are
optional, so if you don&#8217;t supply them then MPF will look for a device
tagged with &#8216;ball_add_live&#8217;. If you don&#8217;t provide a source and you don&#8217;t
have a device with the &#8216;ball_add_live&#8217; tag, MPF will quit.</p>
<p>This method does <em>not</em> increase the game controller&#8217;s count of the
number of balls in play. So if you want to add balls (like in a
multiball scenario), you need to call this method along with
<tt class="docutils literal"><span class="pre">self.machine.game.add_balls_in_play()</span></tt>.)</p>
<p>MPF tracks the number of balls in play separately from the actual balls
on the playfield because there are numerous situations where the two
counts are not the same. For example, if a ball is in a VUK while some
animation is playing, there are no balls on the playfield but still one
ball in play, or if the player has a two-ball multiball and they shoot
them both into locks, there are still two balls in play even though
there are no balls on the playfield. The opposite can also be true,
like when the player tilts then there are still balls on the playfield
but no balls in play.</p>
<p>Explanation of the player_controlled parameter:</p>
<p>Set player_controlled to True to indicate that MPF should wait for the
player to eject the ball from the source_device rather than firing a
coil. The logic works like this:</p>
<p>If the source_device does not have an eject_coil defined, then it&#8217;s
assumed that player_controlled is the only option. (e.g. this is a
traditional plunger.) If the source_device does have an eject_coil
defined, then there are two ways the eject could work. (1) there could
be a &#8220;launch&#8221; button of some kind that&#8217;s used to fire the eject coil,
or (2) the device could be the auto/manual combo style where there&#8217;s a
mechanical plunger but also a coil which can eject the ball.</p>
<p>If player_controlled is true and the device has an eject_coil, MPF will
look for the player_controlled_eject_tag and eject the ball when a
switch with that tag is activated.</p>
<p>If there is no player_controlled_eject_tag, MPF assumes it&#8217;s a manual
plunger and will wait for the ball to disappear from the device based
on the device&#8217;s ball count decreasing.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.add_incoming_ball">
<tt class="descname">add_incoming_ball</tt><big>(</big><em>source</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.add_missing_balls">
<tt class="descname">add_missing_balls</tt><big>(</big><em>balls</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_found">
<tt class="descname">ball_found</tt><big>(</big><em>num=1</em><big>)</big></dt>
<dd><p>Used when a previously missing ball is found. Updates the balls
known and balls missing variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num</strong> (<em>int</em>) &#8211; Specifies how many balls have been found. Default is 1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_lost">
<tt class="descname">ball_lost</tt><big>(</big><big>)</big></dt>
<dd><p>Mark a ball as lost</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_search_begin">
<tt class="descname">ball_search_begin</tt><big>(</big><em>force=False</em><big>)</big></dt>
<dd><p>Begin the ball search process</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_search_disable">
<tt class="descname">ball_search_disable</tt><big>(</big><big>)</big></dt>
<dd><p>Disables ball search.</p>
<p>Note this is used to prevent a future ball search from happening (like
when all balls become contained). This method is not used to cancel an
existing ball search. (Use <cite>ball_search_end</cite> for that.)</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_search_end">
<tt class="descname">ball_search_end</tt><big>(</big><big>)</big></dt>
<dd><p>End the ball search, either because we found the ball or
are giving up.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_search_failed">
<tt class="descname">ball_search_failed</tt><big>(</big><big>)</big></dt>
<dd><p>Ball Search did not find the ball.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ball_search_schedule">
<tt class="descname">ball_search_schedule</tt><big>(</big><em>secs=None</em>, <em>force=False</em><big>)</big></dt>
<dd><p>Schedules a ball search to start. By default it will schedule it
based on the time configured in the machine configuration files.</p>
<p>If a ball search is already scheduled, this method will reset that
schedule to the new time passed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>secs</strong> &#8211; Schedules the ball search that many secs from now.</li>
<li><strong>force</strong> &#8211; Boolean to force a ball search. Set True to force a ball
search. Otherwise it will only schedule it if
self.flag_no_ball_search is False. Default is False</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpf.devices.playfield.Playfield.balls">
<tt class="descname">balls</tt></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpf.devices.playfield.Playfield.class_label">
<tt class="descname">class_label</tt><em class="property"> = 'playfield'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpf.devices.playfield.Playfield.collection">
<tt class="descname">collection</tt><em class="property"> = 'playfields'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpf.devices.playfield.Playfield.config_section">
<tt class="descname">config_section</tt><em class="property"> = 'playfields'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.count_balls">
<tt class="descname">count_balls</tt><big>(</big><em>**kwargs</em><big>)</big></dt>
<dd><p>Used to count the number of balls that are contained in a ball
device. Since this is the playfield device, this method always returns
zero.</p>
<p>Returns: 0</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.eject">
<tt class="descname">eject</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.eject_all">
<tt class="descname">eject_all</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.get_additional_ball_capacity">
<tt class="descname">get_additional_ball_capacity</tt><big>(</big><big>)</big></dt>
<dd><p>Used to find out how many more balls this device can hold. Since this
is the playfield device, this method always returns 999.</p>
<p>Returns: 999</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.is_playfield">
<tt class="descname">is_playfield</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.mark_playfield_active">
<tt class="descname">mark_playfield_active</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.ok_to_confirm_ball_via_playfield_switch">
<tt class="descname">ok_to_confirm_ball_via_playfield_switch</tt><big>(</big><big>)</big></dt>
<dd><p>Used to check whether it&#8217;s ok for a ball device which ejects to the
playfield to confirm its eject via a playfield switch being hit.</p>
<p>Returns: True or False</p>
<p>Right now this is simple. If there are no playfield balls, then any
playfield switch hit is assumed to be from the newly-ejected ball. If
there are other balls on the playfield, then we can&#8217;t use this
confirmation method since we don&#8217;t know whether a playfield switch hit
is from the newly-ejected ball(s) or a current previously-live
playfield ball.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.playfield_switch_hit">
<tt class="descname">playfield_switch_hit</tt><big>(</big><em>**kwargs</em><big>)</big></dt>
<dd><p>A switch tagged with &#8216;&lt;this playfield name&gt;_active&#8217; was just hit,
indicating that there is at least one ball on the playfield.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.devices.playfield.Playfield.remove_incoming_ball">
<tt class="descname">remove_incoming_ball</tt><big>(</big><em>source</em><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="mpf.devices.new_device_template.html"
                        title="previous chapter">mpf.devices.new_device_template module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mpf.devices.playfield_transfer.html"
                        title="next chapter">mpf.devices.playfield_transfer module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/mpf.devices.playfield.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mpf.devices.playfield_transfer.html" title="mpf.devices.playfield_transfer module"
             >next</a> |</li>
        <li class="right" >
          <a href="mpf.devices.new_device_template.html" title="mpf.devices.new_device_template module"
             >previous</a> |</li>
        <li><a href="index.html">Mission Pinball Framework v0.21.0 API Documentation</a> &raquo;</li>
          <li><a href="mpf.html" >mpf package</a> &raquo;</li>
          <li><a href="mpf.devices.html" >mpf.devices package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Brian Madden, Gabe Knuth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>